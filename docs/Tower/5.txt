ITEM Syntax
Crate → Item*

Item → Function
      | Struct
      | Enumeration
      | ConstantItem
      | Trait
      | Implementation

Function →
    FunctionQualifiers fn IDENTIFIER ( FunctionParameters? )
    FunctionReturnType? ( BlockExpression | ; )

FunctionQualifiers → const?

FunctionParameters → FunctionParam ( , FunctionParam )* ,?

FunctionParam → ( FunctionParamPattern | Type )

FunctionParamPattern → Pattern : Type

FunctionReturnType → -> Type

Struct → struct IDENTIFIER ( { StructFields? } | ; )

StructFields → StructField ( , StructField )* ,?

StructField → IDENTIFIER : Type

Enumeration →
    enum IDENTIFIER { EnumVariants? }

EnumVariants → EnumVariant ( , EnumVariant )* ,?

EnumVariant → IDENTIFIER

ConstantItem →
    const IDENTIFIER : Type ( = Expression )? ;

Trait →
    trait IDENTIFIER
    {
        AssociatedItem*
    }

Implementation → InherentImpl | TraitImpl

InherentImpl →
    impl Type {
        AssociatedItem*
    }

TraitImpl →
    impl IDENTIFIER for Type
    {
        AssociatedItem*
    }

AssociatedItem → ConstantItem | Function


STATEMENT Syntax
Statement →
      ;
    | Item
    | LetStatement
    | ExpressionStatement

LetStatement →
    let Pattern ( : Type )?
    ( = Expression )? ;

ExpressionStatement →
      ExpressionWithoutBlock ;
    | ExpressionWithBlock ;?


EXPRESSION Syntax
Expression →
      ExpressionWithoutBlock
    | ExpressionWithBlock

ExpressionWithoutBlock →
        LiteralExpression
      | PathExpression
      | OperatorExpression
      | GroupedExpression
      | ArrayExpression
      | IndexExpression
      | StructExpression
      | CallExpression
      | MethodCallExpression
      | FieldExpression
      | ContinueExpression
      | BreakExpression
      | ReturnExpression
      | UnderscoreExpression

ExpressionWithBlock →
        BlockExpression
      | ConstBlockExpression
      | LoopExpression
      | IfExpression
      | MatchExpression

LiteralExpression →
      CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | INTEGER_LITERAL
    | true
    | false

PathExpression → Path

BlockExpression →
    {
        Statements?
    }

Statements →
      Statement+
    | Statement+ ExpressionWithoutBlock
    | ExpressionWithoutBlock

ConstBlockExpression → const BlockExpression

OperatorExpression →
    NegationExpression
    | ArithmeticOrLogicalExpression
    | ComparisonExpression
    | LazyBooleanExpression
    | TypeCastExpression
    | AssignmentExpression
    | CompoundAssignmentExpression

NegationExpression →
      - Expression
    | ! Expression

ArithmeticOrLogicalExpression →
      Expression + Expression
    | Expression - Expression
    | Expression * Expression
    | Expression / Expression
    | Expression % Expression
    | Expression & Expression
    | Expression | Expression
    | Expression ^ Expression
    | Expression << Expression
    | Expression >> Expression

ComparisonExpression →
      Expression == Expression
    | Expression != Expression
    | Expression > Expression
    | Expression < Expression
    | Expression >= Expression
    | Expression <= Expression

LazyBooleanExpression →
      Expression || Expression
    | Expression && Expression

TypeCastExpression → Expression as Type

AssignmentExpression → Expression = Expression

CompoundAssignmentExpression →
      Expression += Expression
    | Expression -= Expression
    | Expression *= Expression
    | Expression /= Expression
    | Expression %= Expression
    | Expression &= Expression
    | Expression |= Expression
    | Expression ^= Expression
    | Expression <<= Expression
    | Expression >>= Expression

GroupedExpression → ( Expression )

ArrayExpression → [ ArrayElements? ]

ArrayElements →
      Expression ( , Expression )* ,?
    | Expression ; Expression

IndexExpression → Expression [ Expression ]

StructExpression →
    Path { StructExprFields? }

StructExprFields →
    StructExprField ( , StructExprField )* ,?

StructExprField →
        IDENTIFIER
      | IDENTIFIER : Expression

CallExpression → Expression ( CallParams? )

CallParams → Expression ( , Expression )* ,?

MethodCallExpression → Expression . PathExprSegment ( CallParams? )

FieldExpression → Expression . IDENTIFIER

LoopExpression →
    InfiniteLoopExpression
  | PredicateLoopExpression

InfiniteLoopExpression → loop BlockExpression

PredicateLoopExpression → while Conditions BlockExpression

BreakExpression → break Expression?

ContinueExpression → continue

IfExpression →
    if Conditions BlockExpression
    ( else ( BlockExpression | IfExpression ) )?

Conditions →
      Expressionexcept StructExpression
    | LetChain

LetChain → LetChainCondition ( && LetChainCondition )*

LetChainCondition →
      Expressionexcept ExcludedConditions
    | let Pattern = Expressionexcept ExcludedConditions

ExcludedConditions →
      StructExpression
    | LazyBooleanExpression
    | AssignmentExpression
    | CompoundAssignmentExpression

MatchExpression →
    match Scrutinee {
        MatchArms?
    }

Scrutinee → Expressionexcept StructExpression

MatchArms →
    ( MatchArm => ( ExpressionWithoutBlock , | ExpressionWithBlock ,? ) )*
    MatchArm => Expression ,?

MatchArm → Pattern MatchArmGuard?

MatchArmGuard → if Expression

ReturnExpression → return Expression?

UnderscoreExpression → _

/*
Patterns are appeared in the let stmt, parameters of functions and match expressions,
and in case 1 and 2 they are irrefutable, which means that the right must be coorperate 
with the pattern, while the last case is not.
More specifically, let is followed by ID pattern or tuple(anonymous) pattern, acting 
as the definition of the vars, so do parameters. The match expr is similiar to the switch 
stmt in C++, using other kind of patterns to show the options.
*/

PATTERN Syntax
Pattern →
      LiteralPattern
    | IdentifierPattern
    | WildcardPattern
    | TupleStructPattern
    | PathPattern

LiteralPattern → -? LiteralExpression

IdentifierPattern → IDENTIFIER ( @ Pattern )?

WildcardPattern → _

TupleStructPattern → Path ( TupleStructItems? )

TupleStructItems → Pattern ( , Pattern )* ,?

PathPattern → Path //Limitations?

/*
Type are automatically checked in the compiler, and the type sys in syntax explictly 
make an appointment or interface to outside while a limitation to inside. In semantic 
check both side shoule be used. 
*/

TYPE Syntax
Type →
    | PathExprSegment //What about self & Self?
    | ArrayType
    | SliceType
    | InferredType

ArrayType → [ Type ; Expression ]

SliceType → [ Type ]

InferredType → _

/*
Every path(maybe contains identifier) in syntax is a handle to a "object" in 
program, which might be a self-define type, a function, a member name, a enum 
value. The semantic check uses them as key to search/insert in symbols maps.
*/

PATH Syntax
Path → PathExprSegment ( :: PathExprSegment )?

PathExprSegment →
    IDENTIFIER | Self | self