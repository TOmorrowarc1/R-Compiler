/*The first editon of syntax, decribing a program consist of 
only one function "main" and const var declartions. Types of variants
are restrict to int32, uint32, bool, char, string, bytestring, cstring
which are equvilant to all "basic" types. All sugar are erased.*/

ITEM Syntax
Crate →
    Item*

Item →
  | Function
  | ConstantItem

Function →
    fn IDENTIFIER
        ( FunctionParameters? )
        FunctionReturnType?
        ( BlockExpression | ; )

FunctionParameters → FunctionParam ( , FunctionParam )* ,?

FunctionParam → FunctionParamPattern

FunctionParamPattern → IDENTIFIER : Type

FunctionReturnType → -> Type


STATEMENT Syntax
Statement →
      ;
    | Item
    | LetStatement
    | ExpressionStatement

LetStatement → 
    let IDENTIFIER ( : Type )?
    ( = Expression )? ;

ExpressionStatement →
      ExpressionWithoutBlock ;
    | ExpressionWithBlock ;?


EXPRESSION Syntax
Expression →
      ExpressionWithoutBlock
    | ExpressionWithBlock

ExpressionWithoutBlock →
      LiteralExpression
    | OperatorExpression
    | GroupedExpression
    | CallExpression
    | ContinueExpression
    | BreakExpression
    | ReturnExpression
    | UnderscoreExpression
    

ExpressionWithBlock →
      BlockExpression
    | ConstBlockExpression
    | LoopExpression
    | IfExpression

LiteralExpression →
      CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | BYTE_LITERAL
    | BYTE_STRING_LITERAL
    | RAW_BYTE_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | INTEGER_LITERAL
    | true
    | false

BlockExpression →
    {
      Statements?
    }

Statements →
      Statement+
    | Statement+ ExpressionWithoutBlock
    | ExpressionWithoutBlock

ConstBlockExpression → const BlockExpression

OperatorExpression →
    | NegationExpression
    | ArithmeticOrLogicalExpression
    | ComparisonExpression
    | LazyBooleanExpression
    | TypeCastExpression
    | AssignmentExpression
    | CompoundAssignmentExpression

NegationExpression →
      - Expression
    | ! Expression

ArithmeticOrLogicalExpression →
      Expression + Expression
    | Expression - Expression
    | Expression * Expression
    | Expression / Expression
    | Expression % Expression
    | Expression & Expression
    | Expression | Expression
    | Expression ^ Expression
    | Expression << Expression
    | Expression >> Expression

ComparisonExpression →
      Expression == Expression
    | Expression != Expression
    | Expression > Expression
    | Expression < Expression
    | Expression >= Expression
    | Expression <= Expression

LazyBooleanExpression →
      Expression || Expression
    | Expression && Expression

TypeCastExpression → Expression as TypeNoBounds

AssignmentExpression → Expression = Expression

CompoundAssignmentExpression →
      Expression += Expression
    | Expression -= Expression
    | Expression *= Expression
    | Expression /= Expression
    | Expression %= Expression
    | Expression &= Expression
    | Expression |= Expression
    | Expression ^= Expression
    | Expression <<= Expression
    | Expression >>= Expression

GroupedExpression → ( Expression )

CallExpression → Expression ( CallParams? )

CallParams → Expression ( , Expression )* ,?

LoopExpression →
    InfiniteLoopExpression
  | PredicateLoopExpression

InfiniteLoopExpression → loop BlockExpression

PredicateLoopExpression → while Conditions BlockExpression

BreakExpression → break Expression?

ContinueExpression → continue

IfExpression →
    if Conditions BlockExpression
    ( else ( BlockExpression | IfExpression ) )?

Conditions →
      Expressionexcept StructExpression

ReturnExpression → return Expression?


TYPE Syntax
Type →  TypeNoBounds

TypeNoBounds →
    ParenthesizedType
  | IDENTIFIER
  | NeverType
  | InferredType

ParenthesizedType → ( Type )

NeverType → !

InferredType → _