Crate → Item*

Item → Function
      | Struct
      | Enumeration
      | ConstantItem
      | Trait
      | Implementation

Function →
    FunctionQualifiers fn IDENTIFIER
        ( FunctionParameters? )
        FunctionReturnType?
        ( BlockExpression | ; )

FunctionQualifiers → const?

FunctionParameters →
      SelfParam ,?
    | ( SelfParam , )? FunctionParam ( , FunctionParam )* ,?

SelfParam → ( ShorthandSelf | TypedSelf )

ShorthandSelf → &? mut? self

TypedSelf → mut? self : Type

FunctionParam → PatternNoTopAlt : Type

FunctionReturnType → -> Type

Struct →
      StructStruct

StructStruct →
    struct IDENTIFIER ( { StructFields? } | ; )

StructFields → StructField ( , StructField )* ,?

StructField → IDENTIFIER : Type

Enumeration →
    enum IDENTIFIER { EnumVariants? }

EnumVariants → EnumVariant ( , EnumVariant )* ,?

EnumVariant → IDENTIFIER

ConstantItem →
    const IDENTIFIER : Type ( = Expression )? ;

Trait →
    trait IDENTIFIER
    {
        AssociatedItem*
    }

Implementation → InherentImpl | TraitImpl

InherentImpl →
    impl Type {
        AssociatedItem*
    }

TraitImpl →
    impl IDENTIFIER for Type
    {
        AssociatedItem*
    }

AssociatedItem → ConstantItem | Function


Statements summary
Syntax
Statement →
      ;
    | Item
    | LetStatement
    | ExpressionStatement

LetStatement →
    let PatternNoTopAlt ( : Type )?
    ( = Expression )? ;

ExpressionStatement →
      ExpressionWithoutBlock ;
    | ExpressionWithBlock ;?


Expressions summary
Syntax
Expression →
      ExpressionWithoutBlock
    | ExpressionWithBlock

ExpressionWithoutBlock →
        LiteralExpression
      | PathExpression
      | OperatorExpression
      | GroupedExpression
      | ArrayExpression
      | IndexExpression
      | StructExpression
      | CallExpression
      | MethodCallExpression
      | FieldExpression
      | ContinueExpression
      | BreakExpression
      | ReturnExpression
      | UnderscoreExpression

ExpressionWithBlock →
        BlockExpression
      | ConstBlockExpression
      | LoopExpression
      | IfExpression
      | MatchExpression

LiteralExpression →
      CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | INTEGER_LITERAL
    | true
    | false

PathExpression →
      PathInExpression

BlockExpression →
    {
        Statements?
    }

Statements →
      Statement+
    | Statement+ ExpressionWithoutBlock
    | ExpressionWithoutBlock

ConstBlockExpression → const BlockExpression

OperatorExpression →
      BorrowExpression
    | DereferenceExpression
    | NegationExpression
    | ArithmeticOrLogicalExpression
    | ComparisonExpression
    | LazyBooleanExpression
    | TypeCastExpression
    | AssignmentExpression
    | CompoundAssignmentExpression

BorrowExpression →
      ( & | && ) Expression
    | ( & | && ) mut Expression

DereferenceExpression → * Expression

NegationExpression →
      - Expression
    | ! Expression

ArithmeticOrLogicalExpression →
      Expression + Expression
    | Expression - Expression
    | Expression * Expression
    | Expression / Expression
    | Expression % Expression
    | Expression & Expression
    | Expression | Expression
    | Expression ^ Expression
    | Expression << Expression
    | Expression >> Expression

ComparisonExpression →
      Expression == Expression
    | Expression != Expression
    | Expression > Expression
    | Expression < Expression
    | Expression >= Expression
    | Expression <= Expression

LazyBooleanExpression →
      Expression || Expression
    | Expression && Expression

TypeCastExpression → Expression as TypeNoBounds

AssignmentExpression → Expression = Expression

CompoundAssignmentExpression →
      Expression += Expression
    | Expression -= Expression
    | Expression *= Expression
    | Expression /= Expression
    | Expression %= Expression
    | Expression &= Expression
    | Expression |= Expression
    | Expression ^= Expression
    | Expression <<= Expression
    | Expression >>= Expression

GroupedExpression → ( Expression )

ArrayExpression → [ ArrayElements? ]

ArrayElements →
      Expression ( , Expression )* ,?
    | Expression ; Expression

IndexExpression → Expression [ Expression ]

StructExpression →
    PathInExpression { StructExprFields? }

StructExprFields →
    StructExprField ( , StructExprField )* ,?

StructExprField →
        IDENTIFIER
      | IDENTIFIER : Expression

CallExpression → Expression ( CallParams? )

CallParams → Expression ( , Expression )* ,?

MethodCallExpression → Expression . PathExprSegment ( CallParams? )

FieldExpression → Expression . IDENTIFIER

LoopExpression →
    InfiniteLoopExpression
  | PredicateLoopExpression

InfiniteLoopExpression → loop BlockExpression

PredicateLoopExpression → while Conditions BlockExpression

BreakExpression → break Expression?

ContinueExpression → continue

IfExpression →
    if Conditions BlockExpression
    ( else ( BlockExpression | IfExpression ) )?

Conditions →
      ( Expressionexcept StructExpression )
    | LetChain

LetChain → LetChainCondition ( && LetChainCondition )*

LetChainCondition →
      Expressionexcept ExcludedConditions
    | let Pattern = Expressionexcept ExcludedConditions

ExcludedConditions →
      StructExpression
    | LazyBooleanExpression
    | AssignmentExpression
    | CompoundAssignmentExpression

ReturnExpression → return Expression?

UnderscoreExpression → _


Patterns summary
Syntax
Pattern → PatternNoTopAlt

PatternNoTopAlt →
      PatternWithoutRange

PatternWithoutRange →
      LiteralPattern
    | IdentifierPattern
    | WildcardPattern
    | ReferencePattern
    | PathPattern

LiteralPattern → -? LiteralExpression

IdentifierPattern → ref? mut? IDENTIFIER ( @ PatternNoTopAlt )?

WildcardPattern → _

ReferencePattern → ( & | && ) mut? PatternWithoutRange

PathPattern → PathInExpression


Types summary
Syntax
Type → TypeNoBounds

TypeNoBounds →
      TypePath
    | ReferenceType
    | ArrayType
    | UnitType

ArrayType → [ Type ; Expression ]

ReferenceType → & mut? TypeNoBounds

UnitType -> ()


Paths summary
Syntax
PathInExpression →
    PathExprSegment ( :: PathExprSegment )?

PathExprSegment →
    PathIdentSegment

PathIdentSegment →
    IDENTIFIER | Self | self

TypePath → TypePathSegment

TypePathSegment → PathIdentSegment