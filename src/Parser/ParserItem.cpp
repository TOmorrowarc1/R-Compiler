#include "ParserTotal.hpp"
#include "cast.hpp"
#include "exception.hpp"

// These declarations are generated by Gemini.
auto parseItemFnNode(TokenStream &stream) -> std::unique_ptr<ItemFnNode>;
auto parseItemConstNode(TokenStream &stream) -> std::unique_ptr<ItemConstNode>;
auto parseItemStructNode(TokenStream &stream)
    -> std::unique_ptr<ItemStructNode>;
auto parseItemTraitNode(TokenStream &stream) -> std::unique_ptr<ItemTraitNode>;
auto parseItemEnumNode(TokenStream &stream) -> std::unique_ptr<ItemEnumNode>;
auto parseItemImplNode(TokenStream &stream) -> std::unique_ptr<ItemImplNode>;
auto parseFnParameters(TokenStream &stream) -> std::vector<ItemFnPara>;
auto parseSelfPara(TokenStream &stream) -> FnType;
auto parseItemFnPara(TokenStream &stream) -> ItemFnPara;
auto parseItemStructField(TokenStream &stream) -> ItemStructField;
auto parseItemAssociatedItem(TokenStream &stream) -> ItemAssociatedItem;

auto parseItemNode(TokenStream &stream) -> std::unique_ptr<ItemNode> {
  Position position = stream.peek().line;
  switch (stream.peek().type) {
  case TokenType::FN:
    return parseItemFnNode(stream);
  case TokenType::CONST:
    if (stream.peekNum(1).type == TokenType::FN) {
      return parseItemFnNode(stream);
    }
    return parseItemConstNode(stream);
  case TokenType::STRUCT:
    return parseItemStructNode(stream);
  case TokenType::ENUM:
    return parseItemEnumNode(stream);
  case TokenType::TRAIT:
    return parseItemTraitNode(stream);
  case TokenType::IMPL:
    return parseItemImplNode(stream);
  default:
    throw CompilerException("Unexpected token type for ItemNode", position);
  }
  return nullptr;
}

auto parseItemFnNode(TokenStream &stream) -> std::unique_ptr<ItemFnNode> {
  Position position = stream.peek().line;
  std::string ID;
  std::vector<ItemFnPara> parameters;
  std::unique_ptr<TypeNode> returnType;
  std::unique_ptr<ExprBlockNode> body;
  bool const_flag = false;
  FnType fn_type;
  if (stream.peek().type == TokenType::CONST) {
    const_flag = true;
    stream.next();
  }
  stream.next();
  if (stream.peek().type != TokenType::IDENTIFIER) {
    throw CompilerException("Expected identifier after 'fn'", position);
  }
  ID = stream.next().content;
  if (stream.peek().type != TokenType::LEFT_PAREN) {
    throw CompilerException("Expected '(' after function name", position);
  }
  stream.next();
  fn_type = parseSelfPara(stream);
  parameters = parseFnParameters(stream);
  if (stream.peek().type == TokenType::ARROW) {
    stream.next();
    returnType = parseTypeNode(stream);
  } else {
    returnType = nullptr;
  }
  if (stream.peek().type == TokenType::LEFT_BRACE) {
    body = parseExprBlockNode(stream);
  } else if (stream.peek().type == TokenType::SEMICOLON) {
    stream.next();
  } else {
    throw CompilerException("Expected '{' after function signature", position);
  }
  return std::make_unique<ItemFnNode>(ID, std::move(returnType),
                                      std::move(parameters), std::move(body),
                                      fn_type, const_flag, position);
}

auto parseSelfPara(TokenStream &stream) -> FnType {
  Position position = stream.peek().line;
  FnType fn_type = FnType::Fn;
  switch (stream.peek().type) {
  case TokenType::AND: {
    stream.next();
    fn_type = FnType::Method;
    if (stream.peek().type == TokenType::MUT) {
      stream.next();
      fn_type = FnType::MutMethod;
    }
    if (stream.peek().type != TokenType::SELF) {
      throw CompilerException("Expected self after & or &mut", position);
    }
    stream.next();
    if (stream.peek().type != TokenType::RIGHT_PAREN &&
        stream.peek().type != TokenType::COMMA) {
      throw CompilerException("Expected ')' or ',' after self parameter",
                              position);
    }
    if (stream.peek().type == TokenType::COMMA) {
      stream.next();
    }
    break;
  }
  case TokenType::MUT: {
    if (stream.peekNum(1).type == TokenType::SELF) {
      stream.next();
      stream.next();
      if (stream.peek().type != TokenType::RIGHT_PAREN &&
          stream.peek().type != TokenType::COMMA) {
        throw CompilerException("Expected ')' or ',' after self parameter",
                                position);
        if (stream.peek().type == TokenType::COMMA) {
          stream.next();
        }
      }
      fn_type = FnType::MutMethod;
    }
    break;
  }
  case TokenType::SELF: {
    stream.next();
    if (stream.peek().type != TokenType::RIGHT_PAREN &&
        stream.peek().type != TokenType::COMMA) {
      throw CompilerException("Expected ')' or ',' after self parameter",
                              position);
    }
    if (stream.peek().type == TokenType::COMMA) {
      stream.next();
    }
    fn_type = FnType::Method;
    break;
  }
  }
  return fn_type;
}

auto parseFnParameters(TokenStream &stream) -> std::vector<ItemFnPara> {
  Position position = stream.peek().line;
  std::vector<ItemFnPara> parameters;
  if (stream.peek().type != TokenType::RIGHT_PAREN) {
    parameters.push_back(parseItemFnPara(stream));
    while (stream.peek().type == TokenType::COMMA) {
      stream.next();
      if (stream.peek().type == TokenType::RIGHT_PAREN) {
        break;
      }
      parameters.push_back(parseItemFnPara(stream));
    }
  }
  if (stream.peek().type != TokenType::RIGHT_PAREN) {
    throw CompilerException("Expected ')' after function parameters", position);
  }
  stream.next();
  return parameters;
}

auto parseItemFnPara(TokenStream &stream) -> ItemFnPara {
  ItemFnPara param;
  int32_t checkpoint = stream.getIndex();
  try {
    param.pattern = parsePatternNode(stream);
  } catch (CompilerException) {
    param.pattern = nullptr;
    stream.restoreIndex(checkpoint);
  }
  if (stream.peek().type != TokenType::COLON) {
    param.pattern = nullptr;
    stream.restoreIndex(checkpoint);
  } else {
    stream.next();
  }
  param.type = parseTypeNode(stream);
  return param;
}

auto parseItemConstNode(TokenStream &stream) -> std::unique_ptr<ItemConstNode> {
  Position position = stream.peek().line;
  stream.next();
  std::string name;
  std::unique_ptr<TypeNode> type;
  std::unique_ptr<ExprNode> value;
  if (stream.peek().type != TokenType::IDENTIFIER) {
    throw CompilerException("Expected identifier after 'const'", position);
  }
  name = stream.next().content;
  if (stream.peek().type == TokenType::COLON) {
    stream.next();
    type = parseTypeNode(stream);
  } else {
    throw CompilerException("Expected ':' after Const name", position);
  }
  if (stream.peek().type == TokenType::ASSIGN) {
    stream.next();
    value = parseExprNode(stream);
  }
  if (stream.peek().type != TokenType::SEMICOLON) {
    throw CompilerException("Expected ';' after const declaration", position);
  }
  stream.next();
  return std::make_unique<ItemConstNode>(name, std::move(type),
                                         std::move(value), position);
}

auto parseItemStructNode(TokenStream &stream)
    -> std::unique_ptr<ItemStructNode> {
  Position position = stream.peek().line;
  stream.next();
  std::string ID;
  std::vector<ItemStructField> fields;
  if (stream.peek().type == TokenType::IDENTIFIER) {
    ID = stream.next().content;
  } else {
    throw CompilerException("Struct need identifier.", position);
  }
  if (stream.peek().type == TokenType::SEMICOLON) {
    stream.next();
  } else if (stream.peek().type == TokenType::LEFT_BRACE) {
    stream.next();
    if (stream.peek().type != TokenType::RIGHT_BRACE) {
      fields.push_back(parseItemStructField(stream));
      while (stream.peek().type == TokenType::COMMA) {
        stream.next();
        if (stream.peek().type == TokenType::RIGHT_BRACE) {
          break;
        }
        fields.push_back(parseItemStructField(stream));
      }
    }
    if (stream.peek().type != TokenType::RIGHT_BRACE) {
      throw CompilerException("Unexpected token in function parameters",
                              position);
    }
    stream.next();
  } else {
    throw CompilerException("Unexcepted token in struct.", position);
  }
  return std::make_unique<ItemStructNode>(ID, std::move(fields), position);
}

auto parseItemStructField(TokenStream &stream) -> ItemStructField {
  Position position = stream.peek().line;
  ItemStructField field;
  if (stream.peek().type != TokenType::IDENTIFIER) {
    throw CompilerException("Every struct field needs an ID.", position);
  }
  field.identifier = stream.next().content;
  if (stream.next().type != TokenType::COLON) {
    throw CompilerException("Every struct field needs an :.", position);
  }
  field.type = parseTypeNode(stream);
  return field;
}

auto parseItemEnumNode(TokenStream &stream) -> std::unique_ptr<ItemEnumNode> {
  Position position = stream.peek().line;
  stream.next();
  std::string ID;
  std::vector<std::string> variants;
  if (stream.peek().type != TokenType::IDENTIFIER) {
    throw CompilerException("Every enum needs a ID.", position);
  }
  ID = stream.next().content;
  if (stream.peek().type == TokenType::LEFT_BRACE) {
    stream.next();
    if (stream.peek().type != TokenType::RIGHT_BRACE) {
      variants.push_back(stream.next().content);
      while (stream.peek().type == TokenType::COMMA) {
        stream.next();
        if (stream.peek().type == TokenType::RIGHT_BRACE) {
          break;
        }
        variants.push_back(stream.next().content);
      }
    }
    if (stream.peek().type != TokenType::RIGHT_BRACE) {
      throw CompilerException("Enum declaration should end with a }", position);
    }
    stream.next();
  } else {
    throw CompilerException("Unexcepted token in struct.", position);
  }
  return std::make_unique<ItemEnumNode>(ID, std::move(variants), position);
}

auto parseItemTraitNode(TokenStream &stream) -> std::unique_ptr<ItemTraitNode> {
  Position position = stream.peek().line;
  std::string trait_name;
  std::vector<ItemAssociatedItem> items;
  stream.next();
  if (stream.peek().type != TokenType::STRINGLITERAL) {
    throw CompilerException("Impl for trait no name.", position);
  }
  trait_name = stream.next().content;
  if (stream.peek().type != TokenType::LEFT_BRACE) {
    throw CompilerException("Impl needs { after the type.", position);
  }
  stream.next();
  while (stream.peek().type != TokenType::RIGHT_BRACE) {
    items.push_back(parseItemAssociatedItem(stream));
  }
  return std::make_unique<ItemTraitNode>(trait_name, std::move(items),
                                         position);
}

auto parseItemImplNode(TokenStream &stream) -> std::unique_ptr<ItemImplNode> {
  Position position = stream.peek().line;
  std::unique_ptr<TypeNode> type;
  std::vector<ItemAssociatedItem> items;
  std::string trait_name;
  stream.next();
  if (stream.peekNum(1).type == TokenType::FOR) {
    if (stream.peek().type != TokenType::STRINGLITERAL) {
      throw CompilerException("Impl for trait no name.", position);
    }
    trait_name = stream.next().content;
    stream.next();
  }
  type = parseTypeNode(stream);
  if (stream.peek().type != TokenType::LEFT_BRACE) {
    throw CompilerException("Impl needs { after the type.", position);
  }
  stream.next();
  while (stream.peek().type != TokenType::RIGHT_BRACE) {
    items.push_back(parseItemAssociatedItem(stream));
  }
  stream.next();
  return std::make_unique<ItemImplNode>(std::move(type), std::move(items),
                                        trait_name, position);
}

auto parseItemAssociatedItem(TokenStream &stream) -> ItemAssociatedItem {
  bool is_fn = false;
  is_fn = stream.peek().type == TokenType::FN ||
          (stream.peek().type == TokenType::CONST &&
           stream.peekNum(1).type == TokenType::FN);
  ItemAssociatedItem item;
  if (is_fn) {
    item.function = parseItemFnNode(stream);
  } else {
    item.constant = parseItemConstNode(stream);
  }
  return item;
}